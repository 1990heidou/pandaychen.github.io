---
layout:     post
title:      微服务基础之熔断保护（Breaker）
subtitle:
date:       2020-04-01
author:     pandaychen
header-img:
catalog: true
category:   false
tags:
    - 熔断
---


##  0x00    前言

什么是熔断器 / Breaker？

&emsp;&emsp; 熔断器是为了当依赖的服务已经出现故障时，主动阻止对依赖服务的请求（通常情况下是执行本地的服务降级办法，亦或直接返回错误），从而保证自身服务的正常运行不受依赖服务影响，防止雪崩效应。

在实现上，它的思路是在调用方 Caller 增加一种 "避让" 机制，当下游出现异常时能够停止（熔断）对下游的继续请求，当等待一段时间后缓慢放行部分的调用流量，并当这部分流量依旧正常的情况下，解除 "熔断" 状态。当下游再次出现异常时，再次打开，周而复始。

一般而言，熔断保护策略部署在服务端保护策略的最后一级，在限流之后。

##  0x01	原理
熔断器的本质就是状态机，包含了熔断检测、熔断关闭、数据统计三个模块。如下图状态机中三种状态的变迁：

OPEN ------ HALFOPEN ------ CLOSED

-	OPEN状态：熔断器打开，使用快速失败返回，调用链结束

-	HALFOPEN状态：当熔断开启一段时间后，尝试阶段（熔断器打开，但允许放过少部分请求）

-	CLOSED状态：熔断器关闭，正常调用

![image](https://s1.ax1x.com/2020/04/24/J0JYb8.png)

##	0x02	熔断算法指标的量化

![image](https://s1.ax1x.com/2020/04/23/J093dg.png)

当 Service-E 服务出现故障时，Service-B 的熔断检测模块，**主动** 检测到 Client 调用 Service-E 服务错误率达到设置阈值，从而 **主动** 开启熔断，开启熔断的结果，是访问 Service-E 的请求全部返回错误，或者按照默认值处理；当 Service-E 服务恢复时，**自动** 关闭熔断状态。这里的好处：
-   保护了 Service-B 自身的稳定性
-   降低对 Service-E 的透传请求，防止服务链路上引发雪崩效应

在上面的描述中，两个核心点：开启熔断和关闭熔断的策略。针对这两种场景，在编码中需要量化的概念：

熔断检测模块：检测失败率是否超过阈值，开启熔断
-   开启熔断（熔断的阀值量化）：服务错误率
	-   统计区间的总请求数、请求失败数（目标服务调用延迟较大、超时、调用失败都可以作为失败统计指标，要排除掉逻辑错误）
	-	统计方式：一般采用滑动窗口进行统计（避免毛刺现象）
-	熔断判断条件
	-	时间维度：多长时间内的超时请求达到多少，触发熔断
	-	请求维度：多长时间内的错误（超时）请求达到多少，触发熔断

熔断关闭模块：主动探测依赖服务
-	探测服务恢复：如何量化情况好转：多长时间之后超时请求数低于多少关闭熔断
-	关闭熔断：情况好转，恢复目标服务调用

##	0x03	总结
本文介绍了微服务中常用熔断机制的原理，熔断机制是预防服务雪崩的最有效的一种手段。目前在 gRPC 项目中，就使用了 [Hystrix-Go](https://github.com/afex/hystrix-go) 作为客户端的熔断实现。
下面文章分析下 Hystrix-Go 是如何实现熔断机制的。

##  0x04	参考
-   [微服务 - 熔断机制](http://blog.zhuxingsheng.com/blog/micro-service-fuse-mechanism.html)
-   [CircuitBreaker](https://martinfowler.com/bliki/CircuitBreaker.html)

转载请注明出处，本文采用 [CC4.0](http://creativecommons.org/licenses/by-nc-nd/4.0/) 协议授权