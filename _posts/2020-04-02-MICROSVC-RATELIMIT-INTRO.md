---
layout:     post
title:      微服务基础之限流（RateLimit）--（一）
subtitle:   限流的基础概念
date:       2020-04-02
author:     pandaychen
header-img:
catalog: true
category:   false
tags:
    - 限流
---


##  0x00    微服务中的限流
&emsp;&emsp; 这篇博客来介绍下微服务中的服务限流（Ratelimit），它是保证服务稳定的基础组件之一。其他类似的概念还有服务熔断。微服务中的限流主要指业务代码的逻辑限流。
通常，限流策略相较于熔断，使用的更为广泛一些，因为限流的同时可以对其他（被限制）服务请求进行排队处理，而不是像熔断策略直接拒绝掉这些被限制的请求。当然了，简单的处理方式就是被限制的流量，可以根据具体的业务逻辑去处理，直接返回错误或者返回默认值等等。

##  0x01	应用场景
服务器的资源是有限的，同一时间能处理的请求也有限，当请求数量超过服务器能处理的瓶颈时，就会导致所有请求都无法在规定时间内完成。因此需要一种频率限制的算法，来保障单台服务器正在处理的请求数量不超过瓶颈，保证瓶颈以内的请求能顺利处理。
1.	秒杀
2.	恶意刷单
3.	服务路径上关键服务挂掉导致的雪崩问题（限流并不一定能保证服务恢复）

比如，一个服务 A 的接口可能被 BCDE 多个服务进行调用，在 B 服务发生突发流量时，直接把 A 服务给调用挂了，导致 A 服务对 CDE 也无法提供服务。解决方案有两种：
1.  每个 Caller 采用线程池进行资源隔离
2.  使用限流手段对每个 Caller 进行限流

##	0x02	算法实现

本小节，介绍常用的限流算法。无论是何种算法，都可以抽象成下面这张图，当请求发生时，请求方必须拿到请求的令牌，才可以访问到相应的应用。基于令牌的算法实现方式，常见的有这几种限流算法：

![image](https://s1.ax1x.com/2020/04/09/G42Bp4.png)

1.  计数器（Counter）算法
此算法一般会限制一秒钟的能够通过的请求数（counter），比如限流 qps 为 100，那么从第一个请求进来开始计时，在接下去的 1s 内，每来一个请求，就把计数加 1，如果累加的数字达到了 100，那么后续的请求就会被全部拒绝。等到 1s 结束后，把计数恢复成 0，重新开始计数。这个计数器必须是原子的，在golang中可以使用[atomic](https://golang.org/pkg/sync/atomic/)包来实现。

在笔者之前开发DDoS防护的限速策略时，也是采用的计数器`+`hashtable的方式进行限速，但是这种限速是无差别限速，效果非常不好。此外，该算法还存在"毛刺现象"：如果我在单位时间 1s 内的前 10ms，已经通过了 100 个请求，那后面的 990ms，只能拒绝这些请求。

2.  漏桶算法（Leaky bucket）
&emsp;&emsp; 为了消除 "毛刺现象"，可以采用漏桶算法实现限流。算法内部有一个容器（或队列），类似漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。不管服务调用方多么不稳定，通过漏桶算法进行限流，每 10 毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。

-	漏桶算法的缺点：无法应对短时间的突发流量
-	漏桶算法的典型实现：[Uber-Go rate limiter](https://github.com/uber-go/ratelimit)

3.  令牌桶算法（Token bucket）
&emsp;&emsp; 令牌桶算法是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。如下图，可以通过控制令牌的生产速度来完成对突发case的优化。

![image](https://s1.ax1x.com/2020/04/09/G4gEZV.png)

算法中，令牌桶用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。
放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌。所以存在这种情况，令牌桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置 qps 为 100，那么限流器初始化完成1s后，桶中就已经有 100 个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的 100 个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。

令牌桶算法的典型实现：
[Juju-ratelimiter](https://github.com/juju/ratelimit)
[Golang 标准库限流器](https://godoc.org/golang.org/x/time/rate)

##  0x03    限流的配置
限流可以在客户端做，也可以在服务端来做。服务端的限流也叫做流量整形（Traffic Shaping）。

####    限流值配置
在实际项目中，一般采用压测的方式，得到服务端接口的QPS，然后将此值作为配置限流的参考值。

##  0x04    自适应限流
首次接触这个概念是在Kratos项目中，后面文章专门分析下是如何实现自适应限流算法的。Kratos项目中对该算法的描述如下：
>   kratos 借鉴了 Sentinel 项目的自适应限流系统，通过综合分析服务的 cpu 使用率、请求成功的 qps 和请求成功的 rt 来做自适应限流保护

##  0x05    总结
本文介绍了微服务中重要的限流概念，限流机制在微服务架构中用来保护核心服务不被瞬时高并发请求拖垮，起到了关键性的作用。

##	0x06    参考
-	[Go 语言高级编程 (Advanced Go Programming)- 5.6 Ratelimit 服务流量限制](https://chai2010.cn/advanced-go-programming-book/ch5-web/ch5-06-ratelimit.html)
-   [Golang 标准库限流器 time/rate 使用介绍](https://www.cyhone.com/articles/usage-of-golang-rate/)
-   [Kratos自适应限流保护](https://github.com/go-kratos/kratos/blob/master/doc/wiki-cn/ratelimit.md)
-   [Uber-Go rate limiter](https://github.com/uber-go/ratelimit/)